# -*- coding: utf-8 -*-
import numpy as np
import math
import matplotlib.pyplot as plt
from random import random

#Parámetros del vehículo
LARGO=0.35 #[m]
ANCHO=0.2 #[m]
POSEJE=0.08 #Distancia de la parte posterior al eje posterior [m]
RUE_LAR=0.03 #[m]
RUE_AN=0.02 #[m]
HUELLA=0.08 #Separación de las ruedas con las partes laterales [m]
DEJE=0.2 #Distancia entre ejes [m]
MAX_ANG=math.radians(45.0) #Máximo ángulo de gobierno [rad]
MAX_VELANG=math.radians(30.0) #Máxima velocidad para alcanzar el ángulo [rad/s]
MAX_VEL=5.5/3.6 #Máxima velocidad [m/s]
MIN_VEL=-2.0/3.6 #Mínima velocidad [m/s]
MAX_ACE=0.1 #Aceleración máxima [m/s²]

#Parámetros de control
k=0.1 #Ganancia del controlador lateral
Kp=1.0 #Ganancia del controlador de velocidad
dt=0.1 #[s]
Lfc=1.0
#K_rho=9
#K_alpha=15
#K_beta=-3

class Estado:
    def __init__(self, x=.0, y=0.0, th=0.0, v=0.0):
        self.x=x
        self.y=y
        self.th=th
        self.v=v

def nuevo(estado, a, phi):
    estado.x=estado.x+estado.v*math.cos(estado.th)*dt
    estado.y=estado.y+estado.v*math.sin(estado.th)*dt
    estado.th=estado.th+estado.v*math.tan(phi)*dt/LARGO
    estado.v=estado.v+a*dt
    return estado

def PID(obj, act):
    #Sólo proporcional
    a=Kp*(obj-act)
    return a

def pure_pursuit(estado, xf, yf):
    #1) Posición del robot (xf, yf)
    #2.1) El punto más cercano es la propia posición del vehículo
    #2.2) Calcular distancia al siguiente punto
    #2.3) Calcular la curvatura
    alpha=math.atan2(yf-estado.y, xf-estado.x)-estado.th
    if estado.v<0:
        alpha=math.pi-alpha
    L=k*estado.v*Lfc
    #phi=math.atan2(2.0*LARGO*math.sin(alpha), (xf-estado.x)**2+(yf-estado.y)**2)
    phi=math.atan2(2.0*LARGO*math.sin(alpha), L)
    return phi

def grafCar(x, y, th, phi, X, Y):
    if (phi>MAX_ANG):
        phi=MAX_ANG
    Chas=np.matrix([[-POSEJE, (LARGO-POSEJE), (LARGO-POSEJE), -POSEJE, -POSEJE], [ANCHO/2, ANCHO/2, -ANCHO/2, -ANCHO/2, ANCHO/2]])
    Rfd=np.matrix([[RUE_LAR, -RUE_LAR, -RUE_LAR, RUE_LAR, RUE_LAR], [-RUE_AN-HUELLA, -RUE_AN-HUELLA, RUE_AN-HUELLA, RUE_AN-HUELLA, -RUE_AN-HUELLA]])
    Rtd=np.copy(Rfd)
    Rfi=np.copy(Rfd)
    Rfi[1, :]*=-1
    Rti=np.copy(Rtd)
    Rti[1, :]*=-1
    MR1=np.matrix([[math.cos(th), math.sin(th)], [-math.sin(th), math.cos(th)]])
    MR2=np.matrix([[math.cos(phi), math.sin(phi)], [-math.sin(phi), math.cos(phi)]])
    Rfd=(Rfd.T*MR2).T
    Rfi=(Rfi.T*MR2).T
    Rfd[0, :]+=DEJE
    Rfi[0, :]+=DEJE
    Rfd=(Rfd.T*MR1).T
    Rfi=(Rfi.T*MR1).T
    Chas=(Chas.T*MR1).T
    Rtd=(Rtd.T*MR1).T
    Rti=(Rti.T*MR1).T
    Chas[0, :]+=x
    Chas[1, :]+=y
    Rfd[0, :]+=x
    Rfd[1, :]+=y
    Rfi[0, :]+=x
    Rfi[1, :]+=y
    Rtd[0, :]+=x
    Rtd[1, :]+=y
    Rti[0, :]+=x
    Rti[1, :]+=y
    plt.plot(np.array(Chas[0, :]).flatten(), np.array(Chas[1, :]).flatten(), "-k")
    plt.plot(np.array(Rfd[0, :]).flatten(), np.array(Rfd[1, :]).flatten(), "-b")
    plt.plot(np.array(Rfi[0, :]).flatten(), np.array(Rfi[1, :]).flatten(), "-b")
    plt.plot(np.array(Rtd[0, :]).flatten(), np.array(Rtd[1, :]).flatten(), "-b")
    plt.plot(np.array(Rti[0, :]).flatten(), np.array(Rti[1, :]).flatten(), "-b")
    plt.plot(x, y, "*r")
    plt.plot(X, Y, 'b--')
    plt.xlim(0, 5)
    plt.ylim(0, 5)

def main():
    #Valores iniciales y objetivo del robot
    xi=5*random()
    yi=5*random()
    thi=2*math.pi*random()-math.pi
    xf=5*random()
    yf=5*random()
    thf=2*math.pi*random()-math.pi
    phi=math.pi/6
    estado=Estado(x=xi, y=yi, th=thi, v=0.0)
    
    #Parámetros de la simulación
    vel=10.0/3.6 #[m/s]
    MaxT=100.0
    t=0.0
    X=[estado.x]
    Y=[estado.y]
    TH=[estado.th]
    V=[estado.v]
    T=[0.0]
    while MaxT>=t:
        a=PID(vel, estado.v)
        phi=pure_pursuit(estado, xf, yf)
        estado=nuevo(estado, a, phi)
        t=t+dt
        X.append(estado.x)
        Y.append(estado.y)
        TH.append(estado.th)
        V.append(estado.v)
        T.append(t)
        #Animación
        plt.cla()
        plt.grid(True)
        plt.arrow(xi, yi, math.cos(thi), math.sin(thi), color='r', width=0.01)
        plt.arrow(xf, yf, math.cos(thf), math.sin(thf), color='g', width=0.01)
        plt.plot(X, Y, 'b--')
        grafCar(estado.x, estado.y, estado.th, phi, X, Y)
        plt.pause(dt/100)
        plt.show()

if __name__=='__main__':
    main()


"""
def mover(xi, yi, thi, xf, yf, thf, phi):
    x=xi
    y=yi
    th=thi
    xx=xf-x
    yy=yf-y
    X=[]
    Y=[]
    rho=math.sqrt(xx**2+yy**2)
    while rho>0.001:
        X.append(x)
        Y.append(y)
        xx=xf-x
        yy=yf-y
        rho=math.sqrt(xx**2+yy**2)
        alpha=(math.atan2(yy, xx)-th+math.pi)%(2*math.pi)-math.pi
        beta=(thf-th-alpha+math.pi)%(2*math.pi)-math.pi
        v=K_rho*rho
        w=K_alpha*alpha+K_beta*beta
        if alpha>np.pi/2 or alpha<-np.pi/2:
            v=-v
        th=th+v*dt*math.tan(phi)/LARGO
        x=x+v*math.cos(th)*dt
        y=y+v*math.sin(th)*dt
        phi=w*dt
        
        
"""
